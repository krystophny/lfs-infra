#!/bin/sh
# pk - minimal package manager for LFS
# Installs .pkg.tar.xz archives and tracks installed files

set -e

VERSION="1.0.0"
DB_DIR="${PK_ROOT:-}/var/lib/pk"

die() { echo "pk: $*" >&2; exit 1; }

usage() {
    cat <<EOF
pk - minimal package manager

Usage: pk <command> [args]

Commands:
  i, install <pkg.tar.xz>  Install package
  r, remove <pkgname>      Remove package
  l, list                  List installed packages
  q, query <pkgname>       Query package info
  f, files <pkgname>       List package files
  v, version               Show version
EOF
}

# Parse package name and version from filename
# foo-1.2.3.pkg.tar.xz -> name=foo version=1.2.3
parse_pkgname() {
    local basename="${1##*/}"
    basename="${basename%.pkg.tar*}"
    basename="${basename%.tar*}"

    # Find first dash followed by digit (start of version)
    local name="" version="" i=0 char="" rest=""
    rest="$basename"
    while [ -n "$rest" ]; do
        char="${rest%"${rest#?}"}"
        rest="${rest#?}"
        if [ "$char" = "-" ]; then
            next="${rest%"${rest#?}"}"
            case "$next" in
                [0-9])
                    version="$rest"
                    break
                    ;;
            esac
        fi
        name="${name}${char}"
    done

    [ -z "$name" ] && name="$basename"
    [ -z "$version" ] && version="unknown"

    echo "$name" "$version"
}

pkg_install() {
    local archive="$1"
    [ -f "$archive" ] || die "file not found: $archive"

    set -- $(parse_pkgname "$archive")
    local pkgname="$1" version="$2"
    [ -n "$pkgname" ] || die "cannot parse package name"

    local dbdir="$DB_DIR/$pkgname"
    mkdir -p "$dbdir"

    # Extract and record files
    local root="${PK_ROOT:-/}"

    # List files in archive
    tar -tf "$archive" > "$dbdir/files"

    # Extract archive
    tar -xf "$archive" -C "$root"

    # Record package info
    printf '%s\n%s\n' "$pkgname" "$version" > "$dbdir/info"

    echo "installed $pkgname $version"
}

pkg_remove() {
    local pkgname="$1"
    local dbdir="$DB_DIR/$pkgname"
    local fileslist="$dbdir/files"

    [ -f "$fileslist" ] || die "package not installed: $pkgname"

    local root="${PK_ROOT:-/}"

    # Remove files (reverse order, files before directories)
    # First pass: remove files
    while IFS= read -r file; do
        [ -n "$file" ] || continue
        local target="$root/$file"
        [ -f "$target" ] && rm -f "$target"
    done < "$fileslist"

    # Second pass: remove empty directories
    sort -r < "$fileslist" | while IFS= read -r file; do
        [ -n "$file" ] || continue
        local target="$root/$file"
        [ -d "$target" ] && rmdir "$target" 2>/dev/null || true
    done

    rm -rf "$dbdir"
    echo "removed $pkgname"
}

pkg_list() {
    [ -d "$DB_DIR" ] || exit 0
    ls -1 "$DB_DIR" 2>/dev/null || true
}

pkg_query() {
    local pkgname="$1"
    local infofile="$DB_DIR/$pkgname/info"

    if [ ! -f "$infofile" ]; then
        echo "$pkgname is not installed"
        return 1
    fi

    local name="" version=""
    { read -r name; read -r version; } < "$infofile"
    echo "$name $version [installed]"
}

pkg_files() {
    local pkgname="$1"
    local fileslist="$DB_DIR/$pkgname/files"

    [ -f "$fileslist" ] || die "package not installed: $pkgname"
    cat "$fileslist"
}

# Main
[ $# -ge 1 ] || { usage; exit 1; }

cmd="$1"
shift

case "$cmd" in
    i|install)
        [ $# -ge 1 ] || die "usage: pk install <pkg.tar.xz>"
        pkg_install "$1"
        ;;
    r|remove)
        [ $# -ge 1 ] || die "usage: pk remove <pkgname>"
        pkg_remove "$1"
        ;;
    l|list)
        pkg_list
        ;;
    q|query)
        [ $# -ge 1 ] || die "usage: pk query <pkgname>"
        pkg_query "$1"
        ;;
    f|files)
        [ $# -ge 1 ] || die "usage: pk files <pkgname>"
        pkg_files "$1"
        ;;
    v|version)
        echo "pk $VERSION"
        ;;
    *)
        usage
        exit 1
        ;;
esac
